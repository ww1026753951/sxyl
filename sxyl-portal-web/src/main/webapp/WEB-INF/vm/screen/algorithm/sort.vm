<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>思想摇篮</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="keywords" content="冒泡排序"/>
    <meta name="description" content="冒泡排序"/>
    <link href="/css/bootstrap/bootstrap.min.css" rel="stylesheet">
    <script src="/js/d3/d3.min.js"></script>
    <script src="/js/sxyl.js"></script>
</head>
<script>
    var int  ;
</script>
<body>
<div>

##    <button onclick="init()">重置</button>

##    <button onclick="init()">重置</button>

    <button onclick="init()">重置</button>

</div>
<div>
    <button onclick="int = setInterval(bubbleSort,200)">冒泡排序</button>
    <button onclick="int = setInterval(selectionSort,200)">选择排序</button>
    <button onclick="int = setInterval(insertionSort,500)">插入排序</button>
</div>
<script>

    var x = new Array();
    var uuidArray = new Array() ;

    //画布大小
    var width = 2000, height = 2000;
    // 在body里添加一个SVG画布
    var svg = d3.select("body")
            .append("svg")
            .attr("id","sortAlg")
            .attr("width",width)
            .attr("height",height);

    function init() {
        SXYL.i=0;
        SXYL.j=0

        svg.selectAll("g").remove();
        x = new Array();
        uuidArray = new Array() ;

        var arrayLength = 10;
        //起始位置,距屏幕左侧距离
        var circleLeft = 100 ;
        for (var i =0 ; i<arrayLength; i++ ){
            x.push(randomFrom(3,40)) ;
            uuidArray.push(SXYL.base.uuid()) ;
        }

        for (var i=0 ;i< x.length ; i++) {
            if(i > 0){
                circleLeft = circleLeft + 40 ;
            }
            var tarG = svg.append("g")
                    .attr("id", uuidArray[i])
                    .attr("transform", "translate("+circleLeft+","+(300 - x[i]*5)+")");
            tarG.append("rect")
                    .attr("width", 30)
                    .attr("height", x[i]*5)
                    .style("fill","red");
            tarG.append("text")
                    .attr("x", 6)
                    .attr("y", -5)
                    .text(x[i]);
        }
        function randomFrom(lowerValue,upperValue){
            return Math.floor(Math.random() * (upperValue - lowerValue + 1) + lowerValue);
        }
    }

    init();
</script>

<script type="text/javascript">
    /***
     * 冒泡排序算法, 升序算法
     */
    function bubbleSort() {
        console.log("start");
        var iIndex = SXYL.i ;
        for (var i = iIndex ; i < x.length ; i++) {
            var jIndex = SXYL.j ;
            for(var j = jIndex ; j < x.length - 1 -i ; j++){
                console.log("compare index,i="+i+",j="+j+" , a = " + x[j] + ", b = " + x[j+1]);
                //变换颜色
                var leftColor =SXYL.d3.changeElementColor(uuidArray[j], "yellow") ;
                var rightColor =SXYL.d3.changeElementColor(uuidArray[j+1], "yellow") ;
                // debugger
                if(leftColor && rightColor){
                    return ;
                }
                 if(x[j] > x[j+1]){//比较大小 , 说明需要换位置
                    var leftColor =SXYL.d3.changeElementColor(uuidArray[j], "red") ;
                    var rightColor =SXYL.d3.changeElementColor(uuidArray[j+1], "red") ;
                    //元素交换位置
                    SXYL.d3.changeElementTransformX(uuidArray[j] , uuidArray[j+1]);
                    //uuid的数组进行交换
                    SXYL.base.changeArrayElement(uuidArray , j , j+1);
                    //数组的内容进行交换
                    SXYL.base.changeArrayElement(x,j , j+1);
                    console.log("compare end  need change , a = " + x[j] + ",b = " + x[j+1]);

                    if(j == x.length - 2 - i){//如果是最后一位
                        SXYL.d3.changeElementColor(uuidArray[j+1], "green");
                        SXYL.j = 0;
                        SXYL.i++;
                    }else{
                        SXYL.j++ ;
                    }
                    return
                }else{//比较大小,说明不需要换位置
                    //颜色变换回来
                    var leftColor =SXYL.d3.changeElementColor(uuidArray[j], "red") ;
                    var rightColor =SXYL.d3.changeElementColor(uuidArray[j+1], "red") ;
                    console.log("compare end  no change , a = " + x[j] + ",b = " + x[j+1])
                    if(j == x.length - 2 - i){
                        SXYL.d3.changeElementColor(uuidArray[j+1], "green");
                        SXYL.j = 0;
                        SXYL.i++;
                    }else{
                        SXYL.j++;
                    }
                    return;
                }
            }
            if(i == x.length -1){
                //需要判断是升序还是降序? 可放在嵌套循环里， 但是做的判断更多一些
                SXYL.d3.changeElementColor(uuidArray[0], "green");
            }
        }

        console.log("end");
        window.clearInterval(int);
    }

    /***
     * 选择排序算法
     *
     * 遍历数组
     * 取值第一个为最小值， 用蓝色表示。
     *
     * 遍历剩余数组,
     * 取每个元素(用黄色表示)的值与最小元素进行比较。
     * 如果最小值大于遍历的当前的值，则将最小值的标志(蓝色)赋予当前值。
     * 遍历剩余数组end
     *
     * 如果最小元素
     */
    function selectionSort() {
        var  minIndex ;
        console.log("sort start");
        var indexI = SXYL.i;
        for(var i = indexI ; i < x.length-1; i++){
            if(SXYL.selectMinIndex ==0){
                minIndex = i;//记录每次循环的第一个数为该次循环的最小值索引
            }else{
                minIndex = SXYL.selectMinIndex;
            }
            console.log("minInit start,minIndex =" + minIndex +", minContent=" +x[minIndex]);
            if(SXYL.j ==0){
                var minColor =SXYL.d3.changeElementColor(uuidArray[i], "blue") ;
                if(minColor){
                    return ;
                }
            }
            var indexJ = 0 ;
            if(SXYL.j ==0){
                indexJ = i+1;
                SXYL.j = indexJ;
            }else{
                indexJ = SXYL.j ;
            }
            //循环剩余的数组
            for(var j = indexJ ; j < x.length ; j++){
                console.log("compare start j=" + j +",minIndex = " + minIndex+", left =" + x[j] + ",right="+x[minIndex])
                var compareColor =SXYL.d3.changeElementColor(uuidArray[j], "yellow") ;
                if(compareColor){
                    return ;
                }
                if(x[j]<x[minIndex]){
                    var betweenMinColor =SXYL.d3.changeElementColor(uuidArray[minIndex], "red") ;
                    var afterMinColor =SXYL.d3.changeElementColor(uuidArray[j], "blue") ;
                    if(betweenMinColor && afterMinColor){
                        // debugger
                        // minIndex = j;//找到每次循环到的最小值，
                        SXYL.selectMinIndex = j ;
                        SXYL.j++ ;
                        return ;
                    }
                }else{
                    //将比较的颜色切换回来
                    var compareColor =SXYL.d3.changeElementColor(uuidArray[j], "red") ;
                    if(compareColor){
                        SXYL.j++ ;
                        return ;
                    }
                }
            }
            console.log("compare end , minIndex = " + minIndex + ",minContent=" + x[minIndex]);
            debugger;
            if(!(i == minIndex)){

                SXYL.d3.changeElementColor(uuidArray[minIndex], "green");
                //交换位置
                SXYL.d3.changeElementTransformX(uuidArray[i] , uuidArray[minIndex]);
                //uuid的数组进行交换
                SXYL.base.changeArrayElement(uuidArray , minIndex , i);
                //数组的内容进行交换
                SXYL.base.changeArrayElement(x,minIndex , i);

                SXYL.j =0 ;
                SXYL.i++;
                SXYL.selectMinIndex =0 ;
                return ;
            }else{
                SXYL.d3.changeElementColor(uuidArray[minIndex], "green");
                SXYL.j =0 ;
                SXYL.i++;
                SXYL.selectMinIndex =0 ;
                return ;
            }
        }

        console.log("sort end")
        SXYL.d3.changeElementColor(uuidArray[x.length-1], "green");
        window.clearInterval(int);
    }

    /****
     * 插入排序
     */
    function insertionSort() {
        var i,j;
        var changeFlag = false ;
        for(i=1;i<x.length;i++){
            var targetElement = x[i];
            var targetElementId = uuidArray[i];

            debugger
            /***
             * 目标标签挪y坐标
             * **/
            // var rectTarget = d3.select("#" + uuidArray[i]) ;
            // var rectTargetMatrix = SXYL.d3.getTranslation(rectTarget.attr("transform"));
            // var y = parseInt(rectTargetMatrix[1])+200;
            // rectTarget.transition().duration(50).attr("transform", "translate("+rectTargetMatrix[0]+","+y+")");

            for(j = i-1 ;j >= 0;j--){
                if(x[j] > targetElement){
                    // var rectLeft = d3.select("#" + uuidArray[j+1]) ;
                    // var rectLeftMatrix = SXYL.d3.getTranslation(rectLeft.attr("transform"));
                    // var leftx = parseInt(rectLeftMatrix[0]) + 40;
                    // rectLeft.transition().duration(50).attr("transform", "translate("+ leftx +","+rectLeftMatrix[1]+")");

                    uuidArray[j+1] = uuidArray[j];
                    x[j+1]=x[j];
                    changeFlag = true ;
                }else {
                    break;
                }
            }
            if(changeFlag){
                uuidArray[j+1] = targetElementId;
                x[j+1] = targetElement;
                return ;
            }
        }
        debugger
        window.clearInterval(int);
    }


</script>
</body>
</html>